# CH8 엘라스틱서치 클라이언트

엘라스틱서치에서는 다양한 프로그래밍 언어에서 직접적으로 사용할 수 있는 클라이언트 라이브러리를  제공한다. 아직 지원하지 않는 언어에 대해서는 직접 클라이언트를 개발해서 추가할 수 있는 방법도 제공한다.

## 자바 클라이언트 모듈

자바 언어를 위해 제공되는 클라이언트에는 두 가지 종류가 있다. 내부적으로 HTTP 방식으로 REST API를 사용해 접근하는 방식과 네티(Netty) 모듈을 이용해 네이티브 클라이언트를 통해 접근하는 방식이다.

* REST 클라이언트
    - Java High Level REST Client 라고도 불린다.
    - HTTP 방식을 이용해 엘라스틱서치와 통신한다.
    - 내부적으로 HttpClient 모듈을 사용한다.

> HTTP 방식으로 동작하기 떄문에 매우 유연한 사용성을 제공.

> 초기에는 Transport 클라이언트 방식보다 성능 측면에서 조금 떨어지는 부분이 있었지만, 현재는 성능이 많이 개선.


* Transport 클라이언트
    - Java Client 라고도 불린다.
    - 초기부터 제공되던 클라이언트 방식으로, 상대적으로 빠른 속도를 보장한다.
    - 소켓을 이용해 엘라스틱서치와 통신한다.
    - 내부적으로 Netty 모듈을 사용한다.


> 초기 버전의 엘라스틱서치에서는 소켓을 이용하는 Transport 클라이언트만 제공. 

> 일종의 엘라스틱서치 노드와 비슷한 방식으로 동작하기 때문에 속도는 빠르지만, 엘라스틱서치가 버전업 될 때마다 제공되는 기능이나 API의 명세에 따라 클래스나 메서드가 바뀌는 문제 발생.

> 엘라스틱서치 6.4 버전 이후 미지원 예고, 7.0 부터 폐기 예정.

### High Level REST 클라이언트

> https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html


# CH 09 엘라스틱서치와 루씬 이야기

## 엘라스틱서치 샤드 VS 루씬 인덱스

IndexWriter와 IndexSearcher를 가지고 색인과 검색을 동시에 제공하는 루씬 인스턴스를 루씬 인덱스라고 한다. 

루씬 인덱스 내부에는 세그먼트라는 특수한 자료구조가 다수 존재하며, 루씬 인덱스는 세그먼트를 이용해 검색을 수행하는데, 세그먼트는 내부적으로 역색인 구조이기 때문에 이를 통해 빠른 검색결과를 얻을 수 있다.

엘라스틱서치는 루씬 라이브러리를 샤드 내부에 가지고 있으며, 하나의 엘라스틱서치 샤드는 하나의 루씬 인덱스라고 설명할 수 있다. (샤드가 단순히 루씬 그 자체는 아니며, 샤드는 엘라스틱서치에서 추가한 다양한 기능을 포함하고 있다.) 

> 즉 샤드는 자체적으로 데이터를 색인하고 검색할 수 있는 가장 작은 크기의 단일 검색엔진이라고 할 수 있다.

> 엘라스틱서치 인덱스는 물리적으로 분산된 엘라스틱서치 샤드를 논리적인 관점에서 하나의 거대한 데이터로 바라보는 것이다.

루씬 인덱스가 자기 자신이 가지고 있는 세그먼트 내에서만 검색이 가능하다는 것과 달리 샤드는 모든 샤드가 가지고 있는 세그먼트들을 논리적으로 통합해서 검색할 수 있다. 이는 다수의 인스턴스 간에 데이터를 분산해서 저장할 수 있는 근간이 되고, 이를 통해 클러스터를 구축하는 것이 가능해진다.


```
* 세그먼트
    - 루씬 내부에 존재하는 자료구조다.
    - 역색인 구조로 생성되어 읽기에 최적화되어 있다.
    - 하나의 루씬 내부에서만 존재할 수 있고 확장이 불가능하다.

* 루씬 인덱스
    - 검색과 색인 기능을 가진 최소한의 검색엔진이다.
    - IndexWriter로 색인 과정을 통해 세그먼트를 생성한다.
    - IndexSearcher를 이용해 세그먼트를 검색한다.
    - 자신이 가진 세그먼트 내에서만 검색이 가능하다.

* 엘라스틱서치 샤드
    - 엘라스틱서치에서 제공하는 가장 작은 단위의 검색엔진이다.
    - 내부적으로 루씬을 확장해서 검색엔진 역할을 수행한다.
    - 다수의 샤드가 협력해서 존재하는 모든 세그먼트를 검색할 수 있다.
```

### 색인 작업 시 세그먼트의 기본 동작 방식
```
(1). 최초 색인이 요청된 경우
    1. IndexWriter가 세그먼트를 생성한다
    2. IndexSearcher가 생성된 세그먼트를 읽어 검색을 제공한다.

(2). 추가 색인이 요청된 경우
    1. IndexWriter가 세그먼트를 추가 생성한다.
    2. 세그먼트가 추가 생성되는 동안 기존 세그먼트만 읽어 검색 결과를 제공한다.
    3. 세그먼트 생성이 완료되면 생성된 모든 세그먼트를 읽어 검색 결과를 제공한다.

(3). 주기적으로 세그먼트 Merge 작업이 일어날 경우
    1. IndexWriter가 Merge 대상이 되는 세그먼트들을 복제한다.
    2. IndexWriter가 복제한 세그먼트들을 하나의 세그먼트로 합친다.
    3. 복제본 세그먼트들이 하나로 합쳐지는 동안 IndexSearcher는 원본 세그먼트를 읽어 검색 결과를 제공한다.
    4. 복제본 통합 작업이 완료되면 원본 세그먼트와 교체하고 교체된 원본 세그먼트들은 삭제한다.
    5. IndexSearcher는 새로운 세그먼트를 읽어 검색 결과를 제공한다.
```

### 세그먼트 불변성

> 동시성 분제를 회피할 수 있다.
```
불변성이 보장된다면 잠금(Lock)가 필요 없어진다. 다수의 스레드가 동작하는 복잡한 다중 스레드 환경에서는 동시성 문제는 매우 심각한 결과를 초래할 수 있는 민감한 주제다. 수정이 불가능하다면 이러한 동시성 문제를 간단히 피해갈 수 있다.
```

> 시스탬 캐시를 적극적으로 활용할 수 있다.
```
데이터가 OS커널에서 제공하는 시스템 캐시에 한번 생성되면 일정 시간 동안은 그대로 유지된다. 불변성을 보장하지 않을 경우 데이터가 변경될 때마다 시스템 캐시를 삭제하고 다시 생성해야 하는데 이는 성능 측면에서 매우 비용이 큰 작업이므로 최대한 지양해야 한다. 불변성을 보장하면 시스템 캐시를 적극 활용할 수 있게 된다.
```

> 높은 캐시 적중률을 유지할 수 있다.
```
시스템 캐시의 수명이 길어진다. 이는 검색 시 데이터를 항상 메모리에서 읽어 올 수 있다는 의미로서 이를 통해 매우 큰 성능 향상을 꾀할 수 있다.
```

> 리소스를 절감할 수 있다.
```
역색인을 만드는 과정에서 많은 시스템 리소스(CPU, 메모리 I/O)가 사용된다. 수정을 허용하게 되면 일부분이 변경되더라도 해당 역색인을 대상으로 작업해야 하기 때문에 많은 시스템 리소스가 소모된다.
```

### 세그먼트 불변성과 업데이트

```
(1). 세그먼트에서 일부 데이터가 삭제될 경우
    1. 루씬은 삭제도리 데이터가 포함된 세그먼트의 삭제 여부 비트 배열을 확인한다.
    2. 삭제 여부 비트 배열의 flag를 삭제로 표시한다.
    3. 세그먼트에 직접적인 변경사항은 없으므로 세그먼트의 불변성은 해치지 않으며 캐시도 그대로 유지된다.
    4. IndexSearcher는 검색 작업 시 삭제 여부 비트 배열을 항상 먼저 확인하고 삭제 여부가 체크된 데이터를 검색 결과에서 제외한다.

(2). 세그먼트에서 일부 데이터가 수정되는 경우
    1. 앞의 작업(세그먼트에서 일부 데이터가 삭제될 경우)으로 삭제 처리를 먼저 수행한다.
    2. 수정된 데이터를 새로운 세그먼트로 생성한다.
    3. IndexSearcher는 모든 세그먼트를 읽어 검색 결과를 제공한다.
```

### Flush, Commit, Merge

> 루씬 Flush 작업
```
- 세그먼트가 생성된 후 검색이 가능해지도록 수행하는 작업
- write() 함수로 동기화가 수행됐기 떄문에 커널 시스템 캐시에만 데이터가 생성된다.
- 이를 통해 유저 모드에서 파일을 열어서 사용하는 것이 가능해진다.
- 물리적으로 디스크에 쓰여진 상태는 아니다.
```

> 루씬 Commit 작업
```
- 커널 시스템 캐시의 내용을 물리적인 디스크로 쓰는 작업
- 실제 물리적인 디스크에 데이터가 기록되기 때문에 많은 리소스가 필요하다.
```

> 루씬 Merge 작업
```
- 다수의 세그먼트를 하나로 통합하는 작업
- Merge 과정을 통해 삭제 처리된 데이터가 실제 물리적으로 삭제 처리된다.
- 검색할 세그먼트의 개수가 줄어들기 때문에 검색 성능이 좋아진다.
```