# CH_01, CH_02

* 엘라스틱서치가 강력한 이유
    * 오픈소스 검색엔진
    * 전문 검색
        * 내용 전체를 색인해서 특정 단어가 포함된 문서를 검색하는 것
    * 통계분석 
        * 키바나 연결을 통하여 실시간으로 쌓이는 로그를 시각화하고 분석 가능
    * 스키마리스 
        * 정형화되지 않은 다양한 형태의 문서도 자동으로 색인하고 검색 가능
        * 스키마리스 기능은 가급적이면 사용하지 말자(P.38)
        * 인덱스가 자동으로 생성되면서 세부적인 필드 정보(데이터 타입)가 매핑되지 않아 특정 단어를 검색할 때 검색 결과에서 누락될 수 있음
        * 인덱스의 필드가 멀티필드로 구성되어 불필요한 데이터 공간의 낭비가 발생
    * RESTful API
    * 멀티테넌시 (Multi-tenancy)
        * 필드명이 같다면 서로 다른 여러 개의 인덱스도 한번에 조회 가능
    * Document-Oriented
        * 여러 계층의 데이터를 JSON 형식의 구조화된 문서로 인덱스에 저장 할 수 있다. 계층 구조로 문서도 한 번의 쿼리로 쉽게 조회할 수 있다.
    * 역색인
    * 확장성과 가용성
        * 분산 구성해서 확장이 가능

* 엘라스틱서치의 약점
    * 일반적으로 색인된 데이터는 통상적으로 1초 뒤에나 검색이 가능. (준 실시간)
    * 트랙잭션과 롤백 기능을 제공하지 않음. 최악의 경우 데이터 손실의 위험이 있다.
    * 데이터 업데이트 요청이 오면 기존 문서를 삭제하고 변경된 내용으로 새로운 문서를 생성하기 때문에 단순 업데이트 보다 상대적으로 많은 비용이 발생한다. 대신 불변적이라는 이점이 있다.
---
 * 엘라스틱 서치와 관계형 데이터베이스 비교

|Elasticsearch|DB|
|-|-|
|인덱스(index)|데이터베이스(Database)|
|샤드(Shard)|파티션(Partition)|
|문서(Document)|행(Row))|
|필드(Field)|열(Column)|
|매핑(Mapping)|스키마(Schema)|
    * 6.0이하 버전의 엘라스틱서치에서는 하나의 인덱스 내부에 기능에 따라 데이터를 분류하고 여러 개의 타입을 만들어 사용했지만 현재는 하나의 인덱스에 하나의 타입만 구성하도록 변경됨

* 인덱스
    * 색인된 데이터는 하나의 인덱스에 담긴다.
    * 인덱스의 이름은 모두 소문자여야 한다.
    * 인덱스가 없는 상태에서 데이터가 추가된다면 테이터를 이용해 인덱스가 자동으로 생성된다. 

* 샤드
    * 인덱스가 물리적인 공간에 여러 개 파티션으로 나뉘어 구성된 것

* 문서
    * 엘라스틱서치에서 데이터가 저장되는 최소 단위로 기본적으로 JSON 포맷으로 데이터가 저장된다. 
    * 중첩 구조를 지원하기 떄문에 문서 안에 문서를 지정하는 것이 가능하다.

* 필드
    * 문서를 구성하기 위한 속성
    * 하나의 필드는 목적에 따라 다수의 데이터 타입을 가질 수 있다.

* 매핑
    * 문서의 필드와 필드의 속성을 정의하고 그에 따른 색인 방법을 정의하는 프로세스

---
* 클러스터 : 모든 노드의 검색과 색인 작업을 관장하는 논리적인 개념, 물리적인 노드 인스턴스들의 모임.

* 마스터 노드
    * 클러스트를 관리
    * 노드 추가와 제거, 인덱스 생성, 삭제 등 클러스터의 전반적인 관리를 담당

* 데이터 노드
    * 실질적인 데이터를 저장한다. (데이터가 실제로 분산 저장되는 물리적 공간인 샤드가 배치)
    * 검색과 통계 같은 데이터 관련 작업을 수행한다

* 코디네이팅 노드
    * 들어온 요청을 단순히 라운드로빈 방식으로 분산시켜 주는 노드

* 인제스트 노드
    * 색인에 앞서 데이터를 전처리하기 위한 노드.
    * 데이터의 포맷을 변경하기 위해 스크립트로 전처리 파이프라인을 구성하고 실행할 수 있다.

* 레플리카 샤드
    * 프라이머리 샤드의 복제본
    * 엘라스틱 서치는 장애 시 레플리카 샤드를 이용해 샤드를 복구한다. (장애가 발생하면 마스터 노드는 데이터를 재분배하거나 레플리카 샤드를 프라이머리 샤드로 승격)

---

* HTTP를 통해 JSON 형식의 RESTful API를 이용하여 데이터를 추가, 수정, 삭제

|HTTP Method|기능|
|-|-|
|GET|데이터 조회|
|PUT|테이터 생성|
|POST|인덱스 업데이트, 데이터 조회|
|DELETE|데이터 삭제|
|HEAD|인덱스의 정보 확인|

* 인덱스 생성 API : 인덱스 관리 (생성, 삭제)
* 문서 관리 API : 문서의 추가/수정/삭제
    * Id를 지정하지 않고 문서를 생성하면 id 값은 UUID를 통해 무작위로 생성
* 검색 API : 문서 조회
    * URI 방식 : 간단한 쿼리 검색 또는 디버깅시 간편하게 사용
    * Request Body 방식 : URI 방식보다 제약사항이 적어 주로 사용 (JSON 포맷을 이용한 RESTful 방식)
* 집계 API : 문서 통계 
    * 버킷 집계 : 문서의 필드 기준으로 버킷을 집계 (버킷 안에 다른 버킷의 결과를 추가 할 수 있다.)
    * 메트릭 집계 : 문서에서 추출된 값을 가지고 Sum, Max, Min Avg를 계산
    * 매트릭스 집계 : 행렬의 값을 합하거나 곱한다.
    * 파이프라인 집계 : 버킷에서 도출된 결과 문서를 다른 필드 값으로 재분류(다른 집계에 의해 생성된 결과를 다시 한번 집계 가능)

---